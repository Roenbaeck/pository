<html>
    <head>
        <title>Pository - Experimenting with Posits and Assertions</title>
    </head>
    <body>
        
        <script>
            // a posit is formalized as: 
            // ({(i_1,r_1),...,(i_n,r_n)},v,t)
            // it can be implemented as: 
            // an array of identities
            // an array of corresponding unique roles
            // a value
            // an optional timepoint
            function Posit(identities, roles, value, timepoint) {
                if(!this.unique(roles))
                    throw 'RoleConflictException';
                this.identities = identities;
                this.roles = roles;
                this.value = value;
                this.timepoint = timepoint;
            }
            Posit.prototype = {
                identities: null,
                roles: null,
                value: null,
                timepoint: null,
                equals: function (otherPosit) {
                    // if the value differs it is another posit
                    if (otherPosit.value != this.value)
                        return false;
                    // if the timepoint differs it is another posit
                    if (otherPosit.timepoint != this.timepoint)
                        return false;
                    // if the number of identities differ it is another posit
                    if (otherPosit.identities.length != this.identities.length)
                        return false;
                    var index, identity, role;
                    // if the number of identities are the same, but not all 
                    // identites appear with the same roles it is another posit
                    for (var i = 0; i < this.identities.length; i++) {
                        identity = this.identities[i];
                        index = otherPosit.identities.indexOf(identity);
                        if (index < 0) 
                            return false;
                        if (this.roles[index] != otherPosit.roles[index])
                            return false;
                    }
                    return true;
                },
                unique: function (roles) {
                    var seen = {}; // use an object as a hash table
                    for (var i = 0; i < roles.length; i++) {
                        if(seen[roles[i]]) 
                            return false;
                        seen[roles[i]] = 1;
                    }
                    return true;
                },
                toString: function () {
                    return JSON.stringify(this);
                }
            }

            // an assertion is formalized as: 
            // (P,p,Î±,t)
            // it can be implemented as: 
            // an identity of a positor
            // a reference to a posit
            // a value in the range [-1,1] representing the reliability
            // a mandatory timepoint
            function Assertion(positor, posit, reliability, timepoint) {
                if(!this.reliable(reliability))
                    throw 'ReliabilityOutOfRangeException';
                this.positor = positor;
                this.posit = posit;
                this.reliability = reliability;
                this.timepoint = timepoint;
            }
            Assertion.prototype = {
                positor: null,
                posit: null,
                reliability: null,
                timepoint: null,
                // everything must be equal in order for it to be the same assertion
                equals: function (otherPosit) {
                    if (this.positor == otherPosit.positor
                     && this.posit == otherPosit.posit
                     && this.reliability == otherPosit.reliability
                     && this.timepoint == otherPosit.timepoint)
                        return true;
                    return false;
                },
                reliable: function (reliability) {
                    if (reliability > 1 || reliability < -1)
                        return false;
                    return true;
                }
                toString: function () {
                    return JSON.stringify(this);
                }
            }

            // a stack holding a number of posits
            // together with their individual but chain dependent hashes
            function PositStack() {
                this.posits = [];
                this.hashes = [];
            }
            PositStack.prototype = {
                posits: null,
                hashes: null,
                superhashes: null,
                // use a simple hashing function in this proof of concept
                hash: function (json) {
                    var hash = 0, i, chr, len;
                    if (json.length === 0) return hash;
                    for (i = 0, len = json.length; i < len; i++) {
                        chr = json.charCodeAt(i);
                        hash = ((hash << 5) - hash) + chr;
                        hash |= 0; // Convert to 32bit integer
                    }
                    return hash;
                },
                // push returns the index of the added or existing posit
                // the index can serve as an identifier for the posit
                // such that it can be referenced by an assertion
                push: function(posit) {
                    // do not add if already added
                    for(var i = 0; i < this.posits.length; i++) {
                        if(this.posits[i].equals(posit))
                            return i;
                    }
                    posit.hash = this.hashes[this.hashes.length - 1];
                    var json = JSON.stringify(posit);
                    delete posit.hash;
                    this.hashes.push(this.hash(json));
                    return this.posits.push(posit) - 1;
                },
                // returns any posits that have been tampered with
                tampered: function () {
                    var tampered = [];
                    var i = this.hashes.length;
                    var posit;
                    while (--i >= 0) {
                        posit = this.posits[i];
                        posit.hash = this.hashes[i - 1];
                        var json = JSON.stringify(posit);
                        delete posit.hash;
                        if (this.hash(json) != this.hashes[i])
                            tampered.push(posit);
                    }
                    return tampered;
                },
                superhash: function() {
                    return this.hash(JSON.stringify(this.hashes));
                }
            }

            // a stack holding all posits
            var positStack = new PositStack();
            // a static posit
            positStack.push(new Posit([42], ['type'], 'Lunch'));
            // attempt to push an equal posit
            positStack.push(new Posit([42], ['type'], 'Lunch'));
            positStack.push(new Posit([42], ['type'], 'Lunch', 'Friday'));
            positStack.push(new Posit([42], ['type'], 'Dinner', 'Friday'));
            // no posits have yet been tampered with
            alert(
                    'Tampered posits:\n' + 
                    positStack.tampered() + '\n' + 
                    'Superhash:\n' +
                    positStack.superhash()
            );
            // tampering: first a simple change of value
            positStack.posits[0].value = 'Breakfast';
            alert(
                    'Tampered posits:\n' + 
                    positStack.tampered() + '\n' + 
                    'Superhash:\n' +
                    positStack.superhash()
            );
            // tampering: then a more sinister attempt to change the value and recalculate the hash
            positStack.posits[0].value = 'Snacking';
            positStack.hashes[0] = positStack.hash(JSON.stringify(positStack.posits[0]));
            // also note that the superhash will indicate an integrity problem with the hashes
            alert(
                    'Tampered posits:\n' + 
                    positStack.tampered() + '\n' + 
                    'Superhash:\n' +
                    positStack.superhash()
            );


        </script>
    </body>
</html>